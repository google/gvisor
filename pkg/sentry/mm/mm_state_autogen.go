// automatically generated by stateify.

package mm

import (
	"gvisor.dev/gvisor/pkg/state"
)

func (x *aioManager) StateTypeName() string {
	return "pkg/sentry/mm.aioManager"
}

func (x *aioManager) StateFields() []string {
	return []string{
		"contexts",
	}
}

func (x *aioManager) beforeSave() {}

func (x *aioManager) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.contexts)
}

func (x *aioManager) afterLoad() {}

func (x *aioManager) StateLoad(m state.Source) {
	m.Load(0, &x.contexts)
}

func (x *ioResult) StateTypeName() string {
	return "pkg/sentry/mm.ioResult"
}

func (x *ioResult) StateFields() []string {
	return []string{
		"data",
		"ioEntry",
	}
}

func (x *ioResult) beforeSave() {}

func (x *ioResult) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.data)
	m.Save(1, &x.ioEntry)
}

func (x *ioResult) afterLoad() {}

func (x *ioResult) StateLoad(m state.Source) {
	m.Load(0, &x.data)
	m.Load(1, &x.ioEntry)
}

func (x *AIOContext) StateTypeName() string {
	return "pkg/sentry/mm.AIOContext"
}

func (x *AIOContext) StateFields() []string {
	return []string{
		"results",
		"maxOutstanding",
		"outstanding",
	}
}

func (x *AIOContext) beforeSave() {}

func (x *AIOContext) StateSave(m state.Sink) {
	x.beforeSave()
	if !state.IsZeroValue(&x.dead) {
		state.Failf("dead is %#v, expected zero", &x.dead)
	}
	m.Save(0, &x.results)
	m.Save(1, &x.maxOutstanding)
	m.Save(2, &x.outstanding)
}

func (x *AIOContext) StateLoad(m state.Source) {
	m.Load(0, &x.results)
	m.Load(1, &x.maxOutstanding)
	m.Load(2, &x.outstanding)
	m.AfterLoad(x.afterLoad)
}

func (x *aioMappable) StateTypeName() string {
	return "pkg/sentry/mm.aioMappable"
}

func (x *aioMappable) StateFields() []string {
	return []string{
		"AtomicRefCount",
		"mfp",
		"fr",
	}
}

func (x *aioMappable) beforeSave() {}

func (x *aioMappable) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.AtomicRefCount)
	m.Save(1, &x.mfp)
	m.Save(2, &x.fr)
}

func (x *aioMappable) afterLoad() {}

func (x *aioMappable) StateLoad(m state.Source) {
	m.Load(0, &x.AtomicRefCount)
	m.Load(1, &x.mfp)
	m.Load(2, &x.fr)
}

func (x *fileRefcountSet) StateTypeName() string {
	return "pkg/sentry/mm.fileRefcountSet"
}

func (x *fileRefcountSet) StateFields() []string {
	return []string{
		"root",
	}
}

func (x *fileRefcountSet) beforeSave() {}

func (x *fileRefcountSet) StateSave(m state.Sink) {
	x.beforeSave()
	var root *fileRefcountSegmentDataSlices = x.saveRoot()
	m.SaveValue(0, root)
}

func (x *fileRefcountSet) afterLoad() {}

func (x *fileRefcountSet) StateLoad(m state.Source) {
	m.LoadValue(0, new(*fileRefcountSegmentDataSlices), func(y interface{}) { x.loadRoot(y.(*fileRefcountSegmentDataSlices)) })
}

func (x *fileRefcountnode) StateTypeName() string {
	return "pkg/sentry/mm.fileRefcountnode"
}

func (x *fileRefcountnode) StateFields() []string {
	return []string{
		"nrSegments",
		"parent",
		"parentIndex",
		"hasChildren",
		"maxGap",
		"keys",
		"values",
		"children",
	}
}

func (x *fileRefcountnode) beforeSave() {}

func (x *fileRefcountnode) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.nrSegments)
	m.Save(1, &x.parent)
	m.Save(2, &x.parentIndex)
	m.Save(3, &x.hasChildren)
	m.Save(4, &x.maxGap)
	m.Save(5, &x.keys)
	m.Save(6, &x.values)
	m.Save(7, &x.children)
}

func (x *fileRefcountnode) afterLoad() {}

func (x *fileRefcountnode) StateLoad(m state.Source) {
	m.Load(0, &x.nrSegments)
	m.Load(1, &x.parent)
	m.Load(2, &x.parentIndex)
	m.Load(3, &x.hasChildren)
	m.Load(4, &x.maxGap)
	m.Load(5, &x.keys)
	m.Load(6, &x.values)
	m.Load(7, &x.children)
}

func (x *fileRefcountSegmentDataSlices) StateTypeName() string {
	return "pkg/sentry/mm.fileRefcountSegmentDataSlices"
}

func (x *fileRefcountSegmentDataSlices) StateFields() []string {
	return []string{
		"Start",
		"End",
		"Values",
	}
}

func (x *fileRefcountSegmentDataSlices) beforeSave() {}

func (x *fileRefcountSegmentDataSlices) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.Start)
	m.Save(1, &x.End)
	m.Save(2, &x.Values)
}

func (x *fileRefcountSegmentDataSlices) afterLoad() {}

func (x *fileRefcountSegmentDataSlices) StateLoad(m state.Source) {
	m.Load(0, &x.Start)
	m.Load(1, &x.End)
	m.Load(2, &x.Values)
}

func (x *ioList) StateTypeName() string {
	return "pkg/sentry/mm.ioList"
}

func (x *ioList) StateFields() []string {
	return []string{
		"head",
		"tail",
	}
}

func (x *ioList) beforeSave() {}

func (x *ioList) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.head)
	m.Save(1, &x.tail)
}

func (x *ioList) afterLoad() {}

func (x *ioList) StateLoad(m state.Source) {
	m.Load(0, &x.head)
	m.Load(1, &x.tail)
}

func (x *ioEntry) StateTypeName() string {
	return "pkg/sentry/mm.ioEntry"
}

func (x *ioEntry) StateFields() []string {
	return []string{
		"next",
		"prev",
	}
}

func (x *ioEntry) beforeSave() {}

func (x *ioEntry) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.next)
	m.Save(1, &x.prev)
}

func (x *ioEntry) afterLoad() {}

func (x *ioEntry) StateLoad(m state.Source) {
	m.Load(0, &x.next)
	m.Load(1, &x.prev)
}

func (x *MemoryManager) StateTypeName() string {
	return "pkg/sentry/mm.MemoryManager"
}

func (x *MemoryManager) StateFields() []string {
	return []string{
		"p",
		"mfp",
		"layout",
		"privateRefs",
		"users",
		"vmas",
		"brk",
		"usageAS",
		"lockedAS",
		"dataAS",
		"defMLockMode",
		"pmas",
		"curRSS",
		"maxRSS",
		"argv",
		"envv",
		"auxv",
		"executable",
		"dumpability",
		"aioManager",
		"sleepForActivation",
		"vdsoSigReturnAddr",
	}
}

func (x *MemoryManager) StateSave(m state.Sink) {
	x.beforeSave()
	if !state.IsZeroValue(&x.active) {
		state.Failf("active is %#v, expected zero", &x.active)
	}
	if !state.IsZeroValue(&x.captureInvalidations) {
		state.Failf("captureInvalidations is %#v, expected zero", &x.captureInvalidations)
	}
	m.Save(0, &x.p)
	m.Save(1, &x.mfp)
	m.Save(2, &x.layout)
	m.Save(3, &x.privateRefs)
	m.Save(4, &x.users)
	m.Save(5, &x.vmas)
	m.Save(6, &x.brk)
	m.Save(7, &x.usageAS)
	m.Save(8, &x.lockedAS)
	m.Save(9, &x.dataAS)
	m.Save(10, &x.defMLockMode)
	m.Save(11, &x.pmas)
	m.Save(12, &x.curRSS)
	m.Save(13, &x.maxRSS)
	m.Save(14, &x.argv)
	m.Save(15, &x.envv)
	m.Save(16, &x.auxv)
	m.Save(17, &x.executable)
	m.Save(18, &x.dumpability)
	m.Save(19, &x.aioManager)
	m.Save(20, &x.sleepForActivation)
	m.Save(21, &x.vdsoSigReturnAddr)
}

func (x *MemoryManager) StateLoad(m state.Source) {
	m.Load(0, &x.p)
	m.Load(1, &x.mfp)
	m.Load(2, &x.layout)
	m.Load(3, &x.privateRefs)
	m.Load(4, &x.users)
	m.Load(5, &x.vmas)
	m.Load(6, &x.brk)
	m.Load(7, &x.usageAS)
	m.Load(8, &x.lockedAS)
	m.Load(9, &x.dataAS)
	m.Load(10, &x.defMLockMode)
	m.Load(11, &x.pmas)
	m.Load(12, &x.curRSS)
	m.Load(13, &x.maxRSS)
	m.Load(14, &x.argv)
	m.Load(15, &x.envv)
	m.Load(16, &x.auxv)
	m.Load(17, &x.executable)
	m.Load(18, &x.dumpability)
	m.Load(19, &x.aioManager)
	m.Load(20, &x.sleepForActivation)
	m.Load(21, &x.vdsoSigReturnAddr)
	m.AfterLoad(x.afterLoad)
}

func (x *vma) StateTypeName() string {
	return "pkg/sentry/mm.vma"
}

func (x *vma) StateFields() []string {
	return []string{
		"mappable",
		"off",
		"realPerms",
		"dontfork",
		"mlockMode",
		"numaPolicy",
		"numaNodemask",
		"id",
		"hint",
	}
}

func (x *vma) beforeSave() {}

func (x *vma) StateSave(m state.Sink) {
	x.beforeSave()
	var realPerms int = x.saveRealPerms()
	m.SaveValue(2, realPerms)
	m.Save(0, &x.mappable)
	m.Save(1, &x.off)
	m.Save(3, &x.dontfork)
	m.Save(4, &x.mlockMode)
	m.Save(5, &x.numaPolicy)
	m.Save(6, &x.numaNodemask)
	m.Save(7, &x.id)
	m.Save(8, &x.hint)
}

func (x *vma) afterLoad() {}

func (x *vma) StateLoad(m state.Source) {
	m.Load(0, &x.mappable)
	m.Load(1, &x.off)
	m.Load(3, &x.dontfork)
	m.Load(4, &x.mlockMode)
	m.Load(5, &x.numaPolicy)
	m.Load(6, &x.numaNodemask)
	m.Load(7, &x.id)
	m.Load(8, &x.hint)
	m.LoadValue(2, new(int), func(y interface{}) { x.loadRealPerms(y.(int)) })
}

func (x *pma) StateTypeName() string {
	return "pkg/sentry/mm.pma"
}

func (x *pma) StateFields() []string {
	return []string{
		"off",
		"translatePerms",
		"effectivePerms",
		"maxPerms",
		"needCOW",
		"private",
	}
}

func (x *pma) beforeSave() {}

func (x *pma) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.off)
	m.Save(1, &x.translatePerms)
	m.Save(2, &x.effectivePerms)
	m.Save(3, &x.maxPerms)
	m.Save(4, &x.needCOW)
	m.Save(5, &x.private)
}

func (x *pma) afterLoad() {}

func (x *pma) StateLoad(m state.Source) {
	m.Load(0, &x.off)
	m.Load(1, &x.translatePerms)
	m.Load(2, &x.effectivePerms)
	m.Load(3, &x.maxPerms)
	m.Load(4, &x.needCOW)
	m.Load(5, &x.private)
}

func (x *privateRefs) StateTypeName() string {
	return "pkg/sentry/mm.privateRefs"
}

func (x *privateRefs) StateFields() []string {
	return []string{
		"refs",
	}
}

func (x *privateRefs) beforeSave() {}

func (x *privateRefs) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.refs)
}

func (x *privateRefs) afterLoad() {}

func (x *privateRefs) StateLoad(m state.Source) {
	m.Load(0, &x.refs)
}

func (x *pmaSet) StateTypeName() string {
	return "pkg/sentry/mm.pmaSet"
}

func (x *pmaSet) StateFields() []string {
	return []string{
		"root",
	}
}

func (x *pmaSet) beforeSave() {}

func (x *pmaSet) StateSave(m state.Sink) {
	x.beforeSave()
	var root *pmaSegmentDataSlices = x.saveRoot()
	m.SaveValue(0, root)
}

func (x *pmaSet) afterLoad() {}

func (x *pmaSet) StateLoad(m state.Source) {
	m.LoadValue(0, new(*pmaSegmentDataSlices), func(y interface{}) { x.loadRoot(y.(*pmaSegmentDataSlices)) })
}

func (x *pmanode) StateTypeName() string {
	return "pkg/sentry/mm.pmanode"
}

func (x *pmanode) StateFields() []string {
	return []string{
		"nrSegments",
		"parent",
		"parentIndex",
		"hasChildren",
		"maxGap",
		"keys",
		"values",
		"children",
	}
}

func (x *pmanode) beforeSave() {}

func (x *pmanode) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.nrSegments)
	m.Save(1, &x.parent)
	m.Save(2, &x.parentIndex)
	m.Save(3, &x.hasChildren)
	m.Save(4, &x.maxGap)
	m.Save(5, &x.keys)
	m.Save(6, &x.values)
	m.Save(7, &x.children)
}

func (x *pmanode) afterLoad() {}

func (x *pmanode) StateLoad(m state.Source) {
	m.Load(0, &x.nrSegments)
	m.Load(1, &x.parent)
	m.Load(2, &x.parentIndex)
	m.Load(3, &x.hasChildren)
	m.Load(4, &x.maxGap)
	m.Load(5, &x.keys)
	m.Load(6, &x.values)
	m.Load(7, &x.children)
}

func (x *pmaSegmentDataSlices) StateTypeName() string {
	return "pkg/sentry/mm.pmaSegmentDataSlices"
}

func (x *pmaSegmentDataSlices) StateFields() []string {
	return []string{
		"Start",
		"End",
		"Values",
	}
}

func (x *pmaSegmentDataSlices) beforeSave() {}

func (x *pmaSegmentDataSlices) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.Start)
	m.Save(1, &x.End)
	m.Save(2, &x.Values)
}

func (x *pmaSegmentDataSlices) afterLoad() {}

func (x *pmaSegmentDataSlices) StateLoad(m state.Source) {
	m.Load(0, &x.Start)
	m.Load(1, &x.End)
	m.Load(2, &x.Values)
}

func (x *SpecialMappable) StateTypeName() string {
	return "pkg/sentry/mm.SpecialMappable"
}

func (x *SpecialMappable) StateFields() []string {
	return []string{
		"AtomicRefCount",
		"mfp",
		"fr",
		"name",
	}
}

func (x *SpecialMappable) beforeSave() {}

func (x *SpecialMappable) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.AtomicRefCount)
	m.Save(1, &x.mfp)
	m.Save(2, &x.fr)
	m.Save(3, &x.name)
}

func (x *SpecialMappable) afterLoad() {}

func (x *SpecialMappable) StateLoad(m state.Source) {
	m.Load(0, &x.AtomicRefCount)
	m.Load(1, &x.mfp)
	m.Load(2, &x.fr)
	m.Load(3, &x.name)
}

func (x *vmaSet) StateTypeName() string {
	return "pkg/sentry/mm.vmaSet"
}

func (x *vmaSet) StateFields() []string {
	return []string{
		"root",
	}
}

func (x *vmaSet) beforeSave() {}

func (x *vmaSet) StateSave(m state.Sink) {
	x.beforeSave()
	var root *vmaSegmentDataSlices = x.saveRoot()
	m.SaveValue(0, root)
}

func (x *vmaSet) afterLoad() {}

func (x *vmaSet) StateLoad(m state.Source) {
	m.LoadValue(0, new(*vmaSegmentDataSlices), func(y interface{}) { x.loadRoot(y.(*vmaSegmentDataSlices)) })
}

func (x *vmanode) StateTypeName() string {
	return "pkg/sentry/mm.vmanode"
}

func (x *vmanode) StateFields() []string {
	return []string{
		"nrSegments",
		"parent",
		"parentIndex",
		"hasChildren",
		"maxGap",
		"keys",
		"values",
		"children",
	}
}

func (x *vmanode) beforeSave() {}

func (x *vmanode) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.nrSegments)
	m.Save(1, &x.parent)
	m.Save(2, &x.parentIndex)
	m.Save(3, &x.hasChildren)
	m.Save(4, &x.maxGap)
	m.Save(5, &x.keys)
	m.Save(6, &x.values)
	m.Save(7, &x.children)
}

func (x *vmanode) afterLoad() {}

func (x *vmanode) StateLoad(m state.Source) {
	m.Load(0, &x.nrSegments)
	m.Load(1, &x.parent)
	m.Load(2, &x.parentIndex)
	m.Load(3, &x.hasChildren)
	m.Load(4, &x.maxGap)
	m.Load(5, &x.keys)
	m.Load(6, &x.values)
	m.Load(7, &x.children)
}

func (x *vmaSegmentDataSlices) StateTypeName() string {
	return "pkg/sentry/mm.vmaSegmentDataSlices"
}

func (x *vmaSegmentDataSlices) StateFields() []string {
	return []string{
		"Start",
		"End",
		"Values",
	}
}

func (x *vmaSegmentDataSlices) beforeSave() {}

func (x *vmaSegmentDataSlices) StateSave(m state.Sink) {
	x.beforeSave()
	m.Save(0, &x.Start)
	m.Save(1, &x.End)
	m.Save(2, &x.Values)
}

func (x *vmaSegmentDataSlices) afterLoad() {}

func (x *vmaSegmentDataSlices) StateLoad(m state.Source) {
	m.Load(0, &x.Start)
	m.Load(1, &x.End)
	m.Load(2, &x.Values)
}

func init() {
	state.Register((*aioManager)(nil))
	state.Register((*ioResult)(nil))
	state.Register((*AIOContext)(nil))
	state.Register((*aioMappable)(nil))
	state.Register((*fileRefcountSet)(nil))
	state.Register((*fileRefcountnode)(nil))
	state.Register((*fileRefcountSegmentDataSlices)(nil))
	state.Register((*ioList)(nil))
	state.Register((*ioEntry)(nil))
	state.Register((*MemoryManager)(nil))
	state.Register((*vma)(nil))
	state.Register((*pma)(nil))
	state.Register((*privateRefs)(nil))
	state.Register((*pmaSet)(nil))
	state.Register((*pmanode)(nil))
	state.Register((*pmaSegmentDataSlices)(nil))
	state.Register((*SpecialMappable)(nil))
	state.Register((*vmaSet)(nil))
	state.Register((*vmanode)(nil))
	state.Register((*vmaSegmentDataSlices)(nil))
}
